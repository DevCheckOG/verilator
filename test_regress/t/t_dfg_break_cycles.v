// DESCRIPTION: Verilator: Verilog Test module
//
// This file ONLY is placed under the Creative Commons Public Domain, for
// any use, without warranty, 2025 by Geza Lore.
// SPDX-License-Identifier: CC0-1.0

`define signal(name, width) wire [width-1:0] name

module t (
`include "portlist.vh" // Boilerplate generated by t_dfg_break_cycles.py
  rand_a, rand_b, srand_a, srand_b
);

`include "portdecl.vh" // Boilerplate generated by t_dfg_break_cycles.py

  input rand_a;
  input rand_b;
  input srand_a;
  input srand_b;
  wire logic        [63:0] rand_a;
  wire logic        [63:0] rand_b;
  wire logic signed [63:0] srand_a;
  wire logic signed [63:0] srand_b;

  //////////////////////////////////////////////////////////////////////////
  // Interesting user code to cover
  //////////////////////////////////////////////////////////////////////////

  `signal(GRAY_SEL, 3);
  assign GRAY_SEL = rand_a[2:0] ^ 3'(GRAY_SEL[2:1]);

  `signal(GRAY_SHIFT, 3);
  assign GRAY_SHIFT = rand_a[2:0] ^ (GRAY_SHIFT >> 1);

  `signal(GRAY_REV_SEL, 3);
  assign GRAY_REV_SEL = rand_a[2:0] ^ {GRAY_REV_SEL[1:0], 1'b0};

  `signal(GRAY_REV_SHIFT, 3);
  assign GRAY_REV_SHIFT = rand_a[2:0] ^ (GRAY_REV_SHIFT << 1);

  //////////////////////////////////////////////////////////////////////////
  // Fill coverage
  //////////////////////////////////////////////////////////////////////////

  `signal(CONCAT_RHS, 2);
  assign CONCAT_RHS[0] = rand_a[0];
  assign CONCAT_RHS[1] = CONCAT_RHS[0];

  `signal(CONCAT_LHS, 2);
  assign CONCAT_LHS[0] = CONCAT_LHS[1];
  assign CONCAT_LHS[1] = rand_a[1];

  `signal(CONCAT_MID, 3);
  assign CONCAT_MID[0] = |CONCAT_MID[2:1];
  assign CONCAT_MID[2:1] = {rand_a[2], ~rand_a[2]};

  `signal(SEL, 3);
  assign SEL[0] = rand_a[4];
  assign SEL[1] = SEL[0];
  assign SEL[2] = SEL[1];

  `signal(EXTEND, 8);
  assign EXTEND[0] = rand_a[3];
  assign EXTEND[3:1] = 3'(EXTEND[0]);
  assign EXTEND[4] = EXTEND[1];
  assign EXTEND[6:5] = EXTEND[2:1];
  assign EXTEND[7] = EXTEND[3];

  `signal(NOT, 3);
  assign NOT = ~(rand_a[2:0] ^ 3'(NOT[2:1]));

  `signal(AND, 3);
  assign AND = rand_a[2:0] & 3'(AND[2:1]);

  `signal(OR, 3);
  assign OR = rand_a[2:0] | 3'(OR[2:1]);

  `signal(SHIFTR, 14);
  assign SHIFTR = {
    SHIFTR[6:5],         // 13:12
    SHIFTR[7:6],         // 11:10
    SHIFTR[5:4],         // 9:8
    SHIFTR[3:0] >> 2,    // 7:4
    rand_a[3:0]          // 3:0
  };

  `signal(SHIFTR_VARIABLE, 2);
  assign SHIFTR_VARIABLE = rand_a[1:0] ^ ({1'b0, SHIFTR_VARIABLE[1]} >> rand_b[0]);

  `signal(SHIFTL, 14);
  assign SHIFTL = {
    SHIFTL[6:5],         // 13:12
    SHIFTL[7:6],         // 11:10
    SHIFTL[5:4],         // 9:8
    SHIFTL[3:0] << 2,    // 7:4
    rand_a[3:0]          // 3:0
  };

  `signal(SHIFTL_VARIABLE, 2);
  assign SHIFTL_VARIABLE = rand_a[1:0] ^ ({SHIFTL_VARIABLE[0], 1'b0} << rand_b[0]);

  `signal(VAR_A, 2);
  wire logic [1:0] VAR_B;
  assign VAR_A = {rand_a[0], VAR_B[0]};
  assign VAR_B = (VAR_A >> 1) ^ 2'(VAR_B[1]);

  `signal(REPLICATE, 4);
  assign REPLICATE = rand_a[3:0] ^ ({2{REPLICATE[3:2]}} >> 2);

  `signal(PARTIAL, 4);
  assign PARTIAL[0] = rand_a[0];
  // PARTIAL[1] intentionally unconnected
  assign PARTIAL[3:2] = rand_a[3:2] ^ {PARTIAL[2], PARTIAL[0]};

  wire [2:0] array_0 [2];
  assign array_0[0] = rand_a[2:0];
  assign array_0[1] = array_0[0];
  `signal(ARRAY_0, 3);
  assign ARRAY_0 = array_0[1];

  wire [2:0] array_1 [1];
  assign array_1[0][0] = rand_a[0];
  assign array_1[0][1] = array_1[0][0];
  assign array_1[0][2] = array_1[0][1];
  `signal(ARRAY_1, 3);
  assign ARRAY_1 = array_1[0];

  wire [2:0] array_2a [2];
  wire [2:0] array_2b [2];
  assign array_2a[0][0] = rand_a[0];
  assign array_2a[0][1] = array_2b[1][0];
  assign array_2a[0][2] = array_2b[1][1];
  assign array_2a[1] = array_2a[0];
  assign array_2b = array_2a;
  `signal(ARRAY_2, 3);
  assign ARRAY_2 = array_2a[0];

  wire [2:0] array_3 [2];
  assign array_3[0] = rand_a[2:0] ^ array_3[1] >> 1;
  assign array_3[1] = array_3[0];
  `signal(ARRAY_3, 3);
  assign ARRAY_3 = array_3[0];

  `signal(ADD, 8);
  assign ADD = ((ADD << 4) + 8'(rand_a[3:0]));

  `signal(SUB, 8);
  assign SUB = ((SUB << 4) - 8'(rand_a[3:0]));

  `signal(EQ, 2);
  assign EQ = {rand_a[0], EQ >> 1 == rand_b[1:0]};

  `signal(NEQ, 2);
  assign NEQ = {rand_a[0], NEQ >> 1 != rand_b[1:0]};

  `signal(LT, 2);
  assign LT = {rand_a[0], LT >> 1 < rand_b[1:0]};

  `signal(LTE, 2);
  assign LTE = {rand_a[0], LTE >> 1 <= rand_b[1:0]};

  `signal(GT, 2);
  assign GT = {rand_a[0], GT >> 1 > rand_b[1:0]};

  `signal(GTE, 2);
  assign GTE = {rand_a[0], GTE >> 1 >= rand_b[1:0]};

  `signal(COND_THEN, 3);
  assign COND_THEN = {rand_a[0], rand_a[0] ? 2'(COND_THEN << 2) : rand_b[1:0]};

  `signal(COND_ELSE, 3);
  assign COND_ELSE = {rand_a[0], rand_a[0] ? rand_b[1:0] : 2'(COND_ELSE << 2)};

  `signal(COND_COND, 3);
  assign COND_COND = {rand_a[0], (COND_COND >> 2) == 3'b001 ? rand_b[3:2] : rand_b[1:0]};

endmodule
